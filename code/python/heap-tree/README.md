# Max-Heap Tree Implementation

> [!WARNING]
> This code was entirely generated by Gemini 3 Pro.

This project implements a **Max-Heap** data structure using a binary tree with explicit node pointers (parent, left, right), rather than the traditional array-based approach.

## ⚠️ Educational Purpose Only

**Please Note:** This implementation is intended strictly for **educational purposes** to demonstrate how a heap *could* be represented as a linked tree structure.

In practice, heaps are almost always implemented using **arrays** (or lists in Python) for the following reasons:
*   **Memory Efficiency:** Arrays avoid the overhead of storing multiple pointers (left, right, parent) for every element.
*   **Cache Locality:** Array elements are stored contiguously in memory, leading to significantly better cache performance.
*   **Simplicity:** Calculating parent and child indices in an array (`i`, `2*i`, `2*i+1`) is faster and simpler than traversing pointers.

## Usage

```python
from max_heap import MaxHeap

heap = MaxHeap()
heap.insert(10)
heap.insert(20)
heap.insert(5)

print(heap.peek())  # Output: 20
print(heap.extract_max())  # Output: 20
```

## Implementation Details

*   **Node Structure:** Each node contains a value and pointers to its parent, left child, and right child.
*   **Insertion:** Uses the binary representation of the heap size to find the next available position in the complete binary tree.
*   **Extraction:** Replaces the root with the last node in the tree and "bubbles down" to restore the heap property.
